var {{= it.hash }} =
    {{
      const errorReg = /validationErrors\s*?=\s*?\[\s*?{[\s\S]*?keyword:[\s\S]*?'([\s\S]*?)'[\s\S]*?dataPath:[\s\S]*?\+[\s\S]*?\'([\s\S]*?)\s*?,[\s\S]*?params:[\s\S]*?{([\s\S]*?)}[\s\S]*?message:[\s\S]*?'([\s\S]*?)'[\s]*?}\s*?\];[\s\S]*?return false;/g;
      const vErrorReg = /err\s*?=\s*?{[\s\S]*?keyword:[\s\S]*?'([\s\S]*?)'[\s\S]*?dataPath:[\s\S]*?\+[\s\S]*?\'([\s\S]*?)\s*?,[\s\S]*?params:[\s\S]*?{([\s\S]*?)}[\s\S]*?message:[\s\S]*?'([\s\S]*?)'[\s]*?}[\s]*?;[\s]*?(if[\s\S]*?else[\s\S]*?;)/g;
      const oneOfErrorReturn = /validationErrors[\s]*?=[\s]*?vErrors;[\s\S]*?return[\s\S]*?false;/g;
      const propGetter = /\.([^\.]*)'/g;

      let code = it.validate.toString();
      /* Call our own schema var */
      code = code.replace(/validate.schema/g, 'schema');

      /* Call our own error var */
      code = code.replace(/validate.errors/g, 'validationErrors');

      /* Transform returned errors */
      code = code.replace(errorReg, function(match, keyword, dataPath, params, message){
            let replace = "";
            dataPath = dataPath.replace("normalizedHeaders", "headers");
            var allowedVal = (keyword=="enum") ? (": [\' + " + params.replace("allowedValues: ","") + " + ']") : "";
            if(dataPath.indexOf("+")<0){
                dataPath = dataPath.replace(/'/g,"");
                replace = ('\'ValidationError[' + keyword + ']: request' + dataPath + ' ' + message + allowedVal + '\'');
            } else {
                replace = ('\'ValidationError[' + keyword + ']: request' + dataPath + ' + \' ' + message + allowedVal + '\'');
            }
            if(it.singleError){
                return "return " + replace + ";";
            } else {
                return "validationErrors.push(" + replace + ");";
            }
      });

      code = code.replace(vErrorReg, function(match, keyword, dataPath, params, message, errPush){
            let replace = "";
            dataPath = dataPath.replace("normalizedHeaders", "headers");
            if(keyword==="oneOf" && it.singleError){
                errPush = "";
            }
            if(keyword==="const"){
                propGetter.lastIndex = 0;
                let prop = propGetter.exec(dataPath)[1];
                if(it.discriminators.indexOf(prop)>-1){
                    return "err = null;";
                }
            }
            var allowedVal = (keyword=="enum") ? (": [\' + " + params.replace("allowedValues: ","") + " + ']") : "";
            if(dataPath.indexOf("+")<0){
                dataPath = dataPath.replace(/'/g,"");
                replace = ('\'ValidationError[' + keyword + ']: request' + dataPath + ' ' + message + allowedVal + '\'');
            } else {
                replace = ('\'ValidationError[' + keyword + ']: request' + dataPath + ' + \' ' + message + allowedVal + '\'');
            }
            return "err = "+ replace + ";" + errPush;
      });

      /* Mangle ill-behaved property names */
      it.mangledKeys.forEach(function(item){
            var query = "\\.properties\\[['\"]"+item.original+"['\"]\\]";
            var reggy = new RegExp(query, "g");
            code = code.replace(reggy,".properties."+item.mangled);
      });

      /* Protect data properties */
      code = code.replace(/(data[A-Za-z_$0-9]*?)\.(\w+)/g, '$1["$2"]');

      /* Enum property is changed to prevent keyword collision */
      code = code.replace(/.enum;/g, '.api_enum;');

      /* NOTE: this step is no longer needed, there should be no allOf's */
      /* allOf is reformatted into object map to prevent indirection */
      /* code = code.replace(/allOf\[(\d*?)\]/g, 'allOf.t$1'); */

      /* oneOf is reformatted into object map to prevent indirection */
      code = code.replace(/oneOf\[(\d*?)\]/g, 'oneOf.t$1');

      /* Return error array if enabled */
      if (!it.singleError) {
        code = code.replace(/validationErrors[\s]+?=[\s]+?vErrors;[\s]+?return[\s]+?errors[\s]+?===[\s]+?0;/g, "if(vErrors == null || vErrors.length===0){return true;}else{return vErrors;}");
      }

      /* Fix oneOf error return */
      if (it.singleError) {
        code = code.replace(oneOfErrorReturn, "return err;");
      } else {
        /* code = code.replace(oneOfErrorReturn, "(vErrors!=null) ? pushArr(validationErrors, vErrors) : validationErrors.push(err);"); */
      }

      let functionHeader = code.substring(0, code.indexOf("{"));
      let functionBody = code.substring(code.indexOf("{") + 1, code.lastIndexOf("}"));
    }}
    {{= functionHeader}} {
    let validationErrors = {{=(it.singleError) ? "null" : "[]"}};
    {{~ it.validate.source.defaults:d:i }}
      {{= "\/**@const*\/"}} const default{{=i}} = {{=JSON.stringify(d)}};
    {{~}}
    {{= "\/**@const*\/"}} const schema = {{= JSON.stringify(it.schema )}};
    {{
      let patterns = it.validate.source.patterns.map(function(pattern, id){
        pattern = pattern.replace(/\\/g,'\\\\');
        return ("\/**@const*\/ const pattern" + id + " = new RegExp(\"" + pattern + "\");");
      });
    }}
    {{= patterns.join("") }}
    {{= functionBody}}
};