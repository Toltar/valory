{"id":"71Ig","dependencies":[{"name":"/home/john/workspace/Valory2/tsconfig.json","includedInParent":true,"mtime":1531152310742},{"name":"/home/john/workspace/Valory2/package.json","includedInParent":true,"mtime":1533664046105},{"name":"/home/john/workspace/Valory2/.babelrc","includedInParent":true,"mtime":1533664058125},{"name":"../utils/jsDocUtils","loc":{"line":12,"column":29},"parent":"/home/john/workspace/Valory2/src/tsoa/metadataGeneration/resolveType.ts","resolved":"/home/john/workspace/Valory2/src/tsoa/utils/jsDocUtils.ts"},{"name":"../utils/validatorUtils","loc":{"line":13,"column":33},"parent":"/home/john/workspace/Valory2/src/tsoa/metadataGeneration/resolveType.ts","resolved":"/home/john/workspace/Valory2/src/tsoa/utils/validatorUtils.ts"},{"name":"./exceptions","loc":{"line":14,"column":29},"parent":"/home/john/workspace/Valory2/src/tsoa/metadataGeneration/resolveType.ts","resolved":"/home/john/workspace/Valory2/src/tsoa/metadataGeneration/exceptions.ts"},{"name":"./metadataGenerator","loc":{"line":15,"column":36},"parent":"/home/john/workspace/Valory2/src/tsoa/metadataGeneration/resolveType.ts","resolved":"/home/john/workspace/Valory2/src/tsoa/metadataGeneration/metadataGenerator.ts"}],"generated":{"js":"var $Ig$exports={},$Ig$var$__importStar=$Ig$exports&&$Ig$exports.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty($Ig$exports,\"__esModule\",{value:!0});const $Ig$var$lodash_1=require(\"lodash\"),$Ig$var$ts=$Ig$var$__importStar(require(\"typescript\")),$Ig$var$jsDocUtils_1=$parcel$require(\"71Ig\",\"../utils/jsDocUtils\"),$Ig$var$validatorUtils_1=$parcel$require(\"71Ig\",\"../utils/validatorUtils\"),$Ig$var$exceptions_1=$parcel$require(\"71Ig\",\"./exceptions\"),$Ig$var$metadataGenerator_1=$parcel$require(\"71Ig\",\"./metadataGenerator\"),$Ig$var$syntaxKindMap={};$Ig$var$syntaxKindMap[$Ig$var$ts.SyntaxKind.NumberKeyword]=\"number\",$Ig$var$syntaxKindMap[$Ig$var$ts.SyntaxKind.StringKeyword]=\"string\",$Ig$var$syntaxKindMap[$Ig$var$ts.SyntaxKind.BooleanKeyword]=\"boolean\",$Ig$var$syntaxKindMap[$Ig$var$ts.SyntaxKind.VoidKeyword]=\"void\";const $Ig$var$localReferenceTypeCache={},$Ig$var$inProgressTypes={};function $Ig$var$resolveType(e,t,r=!0){const a=$Ig$var$getPrimitiveType(e,t);if(a)return a;if(e.kind===$Ig$var$ts.SyntaxKind.ArrayType)return{dataType:\"array\",elementType:$Ig$var$resolveType(e.elementType)};if(e.kind===$Ig$var$ts.SyntaxKind.UnionType){const t=e;if(t.types.some(e=>e.kind===$Ig$var$ts.SyntaxKind.LiteralType)){for(var n=t.types,$=e=>{const t=e.literal;switch(t.kind){case $Ig$var$ts.SyntaxKind.TrueKeyword:return\"true\";case $Ig$var$ts.SyntaxKind.FalseKeyword:return\"false\";default:return String(t.text)}},i=[],o=0;o<n.length;o++)i.push($(n[o]));return{dataType:\"enum\",enums:i}}return{dataType:\"object\"}}if(e.kind===$Ig$var$ts.SyntaxKind.AnyKeyword)return{dataType:\"any\"};if(e.kind===$Ig$var$ts.SyntaxKind.TypeLiteral){return $Ig$var$getTypeLiteral(e,t)}if(e.kind===$Ig$var$ts.SyntaxKind.LiteralType){const t=e;let r;switch(t.literal.kind){case $Ig$var$ts.SyntaxKind.StringLiteral:r=t.literal.text;break;case $Ig$var$ts.SyntaxKind.NumericLiteral:r=parseFloat(t.literal.text);break;default:r=String(t.literal.text)}return{dataType:\"enum\",enums:[r]}}if(e.kind!==$Ig$var$ts.SyntaxKind.TypeReference)throw new $Ig$var$exceptions_1.GenerateMetadataError(`Unknown type: ${$Ig$var$ts.SyntaxKind[e.kind]}`);const s=e;if(s.typeName.kind===$Ig$var$ts.SyntaxKind.Identifier){if(\"Date\"===s.typeName.text)return $Ig$var$getDateType(e,t);if(\"Buffer\"===s.typeName.text)return{dataType:\"buffer\"};if(\"Array\"===s.typeName.text&&s.typeArguments&&1===s.typeArguments.length)return{dataType:\"array\",elementType:$Ig$var$resolveType(s.typeArguments[0])};if(\"Promise\"===s.typeName.text&&s.typeArguments&&1===s.typeArguments.length)return $Ig$var$resolveType(s.typeArguments[0]);if(\"String\"===s.typeName.text)return{dataType:\"string\"}}if(!r){const e=$Ig$var$getEnumerateType(s.typeName,r);if(e)return e}const g=$Ig$var$getLiteralType(s.typeName);if(g)return g;let d;if(s.typeArguments&&1===s.typeArguments.length){const e=s.typeArguments;d=$Ig$var$getReferenceType(s.typeName,r,e)}else d=$Ig$var$getReferenceType(s.typeName,r);return $Ig$var$metadataGenerator_1.MetadataGenerator.current.AddReferenceType(d),d}var $Ig$export$resolveType=$Ig$var$resolveType;function $Ig$var$getInitializerValue(e,t){if(e)switch(e.kind){case $Ig$var$ts.SyntaxKind.ArrayLiteralExpression:for(var r=e.elements,a=e=>$Ig$var$getInitializerValue(e),n=[],$=0;$<r.length;$++)n.push(a(r[$]));return n;case $Ig$var$ts.SyntaxKind.StringLiteral:return e.text;case $Ig$var$ts.SyntaxKind.TrueKeyword:return!0;case $Ig$var$ts.SyntaxKind.FalseKeyword:return!1;case $Ig$var$ts.SyntaxKind.NumberKeyword:case $Ig$var$ts.SyntaxKind.FirstLiteralToken:return Number(e.text);case $Ig$var$ts.SyntaxKind.NewExpression:const y=e;if(\"Date\"===y.expression.text){let e=new Date;if(y.arguments){for(var i=y.arguments.filter(e=>void 0!==e.kind),o=e=>$Ig$var$getInitializerValue(e),s=[],g=0;g<i.length;g++)s.push(o(i[g]));const t=s;t.length>0&&(e=new Date(t))}const r=e.toISOString();return t&&\"date\"===t.dataType?r.split(\"T\")[0]:r}return;case $Ig$var$ts.SyntaxKind.ObjectLiteralExpression:const c={};for(var d=e.properties,l=e=>{c[e.name.text]=$Ig$var$getInitializerValue(e.initializer)},p=0;p<d.length;p++)l(d[p]);return c;default:return}}$Ig$exports.resolveType=$Ig$export$resolveType;var $Ig$export$getInitializerValue=$Ig$var$getInitializerValue;function $Ig$var$getPrimitiveType(e,t){const r=$Ig$var$syntaxKindMap[e.kind];if(r){if(\"number\"===r){if(!t)return{dataType:\"double\"};const e=$Ig$var$jsDocUtils_1.getJSDocTagNames(t).filter(e=>[\"isInt\",\"isLong\",\"isFloat\",\"isDouble\"].some(t=>t===e));if(0===e.length)return{dataType:\"double\"};switch(e[0]){case\"isInt\":return{dataType:\"integer\"};case\"isLong\":return{dataType:\"long\"};case\"isFloat\":return{dataType:\"float\"};case\"isDouble\":default:return{dataType:\"double\"}}}return{dataType:r}}}function $Ig$var$getDateType(e,t){if(!t)return{dataType:\"datetime\"};const r=$Ig$var$jsDocUtils_1.getJSDocTagNames(t).filter(e=>[\"isDate\",\"isDateTime\"].some(t=>t===e));if(0===r.length)return{dataType:\"datetime\"};switch(r[0]){case\"isDate\":return{dataType:\"date\"};case\"isDateTime\":default:return{dataType:\"datetime\"}}}function $Ig$var$getAliasType(e){if(e.kind!==$Ig$var$ts.SyntaxKind.TypeAliasDeclaration)return;const t=e;return t.type.kind!==$Ig$var$ts.SyntaxKind.IntersectionType?(t.type.kind,$Ig$var$ts.SyntaxKind.TypeReference,{type:$Ig$var$resolveType(e.type,e.type.parent),description:$Ig$var$getNodeDescription(e),format:$Ig$var$getNodeFormat(e),refName:e.name.text,validators:$Ig$var$validatorUtils_1.getPropertyValidators(e),dataType:\"refAlias\",example:$Ig$var$getNodeExample(e)}):void 0}function $Ig$var$getEnumerateType(e,t=!0){const r=e.text,a=$Ig$var$metadataGenerator_1.MetadataGenerator.current.nodes.filter(e=>e.kind===$Ig$var$ts.SyntaxKind.EnumDeclaration).filter(e=>e.name.text===r);if(!a.length)return;if(a.length>1)throw new $Ig$var$exceptions_1.GenerateMetadataError(`Multiple matching enum found for enum ${r}; please make enum names unique.`);const n=a[0];function $(e){const t=e.initializer;if(t)return t.expression?t.expression.text:t.text}if(t){for(var i=n.members,o=(e,t)=>$(e)||String(t),s=[],g=0;g<i.length;g++)s.push(o(i[g],g));const e=s;return{dataType:\"refEnum\",description:$Ig$var$getNodeDescription(n),enums:e,refName:r}}for(var d=n.members,l=(e,t)=>$(e)||String(t),p=[],y=0;y<d.length;y++)p.push(l(d[y],y));return{dataType:\"enum\",enums:p}}function $Ig$var$getNodeExample(e){const t=$Ig$var$jsDocUtils_1.getJSDocComment(e,\"example\");return t?JSON.parse(t):void 0}function $Ig$var$getNodeSwagger(e){const t=$Ig$var$jsDocUtils_1.getJSDocComment(e,\"swagger\");return t?JSON.parse(t):void 0}function $Ig$var$getTypeLiteral(e,t){return{dataType:\"object\",properties:$Ig$var$getModelProperties(e),additionalProperties:$Ig$var$getModelAdditionalProperties(e),description:$Ig$var$getNodeDescription(null!=e.parent?e.parent:e)}}function $Ig$var$getLiteralType(e){const t=e.text,r=$Ig$var$metadataGenerator_1.MetadataGenerator.current.nodes.filter(e=>e.kind===$Ig$var$ts.SyntaxKind.TypeAliasDeclaration).filter(e=>{const t=e.type;return t.kind===$Ig$var$ts.SyntaxKind.UnionType&&t.types}).filter(e=>e.name.text===t);if(r.length){if(r.length>1)throw new $Ig$var$exceptions_1.GenerateMetadataError(`Multiple matching enum found for enum ${t}; please make enum names unique.`);for(var a=r[0].type.types,n=e=>e.literal.text,$=[],i=0;i<a.length;i++)$.push(n(a[i]));return{dataType:\"enum\",enums:$}}}function $Ig$var$getReferenceType(e,t=!0,r){const a=$Ig$var$resolveFqTypeName(e),n=$Ig$var$getTypeName(a,r);try{const t=$Ig$var$localReferenceTypeCache[n];if(t)return t;const $=$Ig$var$getEnumerateType(e,!0);if($)return $Ig$var$localReferenceTypeCache[n]=$,$;if($Ig$var$inProgressTypes[n])return $Ig$var$createCircularDependencyResolver(n);$Ig$var$inProgressTypes[n]=!0;const i=$Ig$var$getModelTypeDeclaration(e),o=$Ig$var$getAliasType(i);if(o)return $Ig$var$localReferenceTypeCache[n]=o,o;const s=$Ig$var$getModelProperties(i,r),g=$Ig$var$getModelAdditionalProperties(i),d=$Ig$var$getModelInheritedProperties(i)||[],l=$Ig$var$getNodeExample(i),p=$Ig$var$getNodeSwagger(i),y={additionalProperties:g,dataType:\"refObject\",description:$Ig$var$getNodeDescription(i),properties:d,refName:n};return y.properties=y.properties.concat(s),$Ig$var$localReferenceTypeCache[n]=y,l&&(y.example=l),p&&(y.additionalSwagger=p),y}catch(e){throw e.message=`There was a problem resolving type of '${$Ig$var$getTypeName(a,r)}'.\\n`+e.message,e}}function $Ig$var$resolveFqTypeName(e){if(e.kind===$Ig$var$ts.SyntaxKind.Identifier)return e.text;const t=e;return $Ig$var$resolveFqTypeName(t.left)+\".\"+t.right.text}function $Ig$var$getTypeName(e,t){if(!t||!t.length)return e;for(var r=t,a=e=>$Ig$var$getAnyTypeName(e),n=[],$=0;$<r.length;$++)n.push(a(r[$]));return e+n.join(\"\")}function $Ig$var$getAnyTypeName(e){const t=$Ig$var$syntaxKindMap[e.kind];if(t)return t;if(e.kind===$Ig$var$ts.SyntaxKind.ArrayType){return $Ig$var$getAnyTypeName(e.elementType)+\"Array\"}if(e.kind===$Ig$var$ts.SyntaxKind.UnionType)return\"object\";if(e.kind===$Ig$var$ts.SyntaxKind.TypeLiteral)return\"object\";if(e.kind!==$Ig$var$ts.SyntaxKind.TypeReference)throw new $Ig$var$exceptions_1.GenerateMetadataError(`Unknown type: ${$Ig$var$ts.SyntaxKind[e.kind]}.`);const r=e;try{return r.typeName.text}catch(t){return console.error(t),e.toString()}}function $Ig$var$createCircularDependencyResolver(e){const t={dataType:\"refObject\",refName:e};return $Ig$var$metadataGenerator_1.MetadataGenerator.current.OnFinish(r=>{const a=r[e];a&&(t.description=a.description,t.dataType=a.dataType,t.refName=t.refName,\"refAlias\"===t.dataType&&\"refAlias\"===a.dataType?(t.validators=a.validators,t.example=a.example,t.format=a.format,t.type=a.type):t.properties=a.properties)}),t}function $Ig$var$nodeIsUsable(e){switch(e.kind){case $Ig$var$ts.SyntaxKind.InterfaceDeclaration:case $Ig$var$ts.SyntaxKind.ClassDeclaration:case $Ig$var$ts.SyntaxKind.TypeAliasDeclaration:case $Ig$var$ts.SyntaxKind.EnumDeclaration:return!0;default:return!1}}function $Ig$var$resolveLeftmostIdentifier(e){for(;e.kind!==$Ig$var$ts.SyntaxKind.Identifier;)e=e.left;return e}function $Ig$var$resolveModelTypeScope(e,t){for(;e.parent&&e.parent.kind===$Ig$var$ts.SyntaxKind.QualifiedName;){const r=e.kind===$Ig$var$ts.SyntaxKind.Identifier?e.text:e.right.text,a=t.filter(e=>{if(e.kind!==$Ig$var$ts.SyntaxKind.ModuleDeclaration||!$Ig$var$metadataGenerator_1.MetadataGenerator.current.IsExportedNode(e))return!1;return e.name.text.toLowerCase()===r.toLowerCase()});if(!a.length)throw new $Ig$var$exceptions_1.GenerateMetadataError(`No matching module declarations found for ${r}.`);if(a.length>1)throw new $Ig$var$exceptions_1.GenerateMetadataError(`Multiple matching module declarations found for ${r}; please make module declarations unique.`);const n=a[0].body;if(null===n||n.kind!==$Ig$var$ts.SyntaxKind.ModuleBlock)throw new $Ig$var$exceptions_1.GenerateMetadataError(`Module declaration found for ${r} has no body.`);t=n.statements,e=e.parent}return t}function $Ig$var$getModelTypeDeclaration(e){const t=$Ig$var$resolveModelTypeScope($Ig$var$resolveLeftmostIdentifier(e),$Ig$var$metadataGenerator_1.MetadataGenerator.current.nodes),r=e.kind===$Ig$var$ts.SyntaxKind.Identifier?e.text:e.right.text;let a=t.filter(e=>{if(!$Ig$var$nodeIsUsable(e)||!$Ig$var$metadataGenerator_1.MetadataGenerator.current.IsExportedNode(e))return!1;return e.name.text===r});if(!a.length)throw new $Ig$var$exceptions_1.GenerateMetadataError(`No matching model found for referenced type ${r}.`);if(a.length>1){const e=(a=a.filter(e=>!(e.getSourceFile().fileName.replace(/\\\\/g,\"/\").toLowerCase().indexOf(\"node_modules/typescript\")>-1))).filter(e=>{return $Ig$var$jsDocUtils_1.isExistJSDocTag(e,e=>\"tsoaModel\"===e.tagName.text)});if(e.length>0){if(e.length>1)throw new $Ig$var$exceptions_1.GenerateMetadataError(`Multiple models for ${r} marked with '@tsoaModel'; '@tsoaModel' should only be applied to one model.`);a=e}}if(a.length>1){for(var n=a,$=e=>e.getSourceFile().fileName,i=[],o=0;o<n.length;o++)i.push($(n[o]));const e=i.join('\"; \"');throw new $Ig$var$exceptions_1.GenerateMetadataError(`Multiple matching models found for referenced type ${r};\\n\\t\\t\\t please make model names unique. Conflicts found: \"${e}\".`)}return a[0]}function $Ig$var$getModelProperties(e,t){const r=e=>{return $Ig$var$jsDocUtils_1.isExistJSDocTag(e,e=>\"ignore\"===e.tagName.text)};if(e.kind===$Ig$var$ts.SyntaxKind.InterfaceDeclaration||e.kind===$Ig$var$ts.SyntaxKind.TypeLiteral){for(var a=e.members.filter(e=>{return!r(e)&&e.kind===$Ig$var$ts.SyntaxKind.PropertySignature}),n=r=>{const a=r,n=a.name;if(!a.type)throw new $Ig$var$exceptions_1.GenerateMetadataError(\"No valid type found for property declaration.\");let $=a.type;if($.kind===$Ig$var$ts.SyntaxKind.TypeReference&&t&&t.length&&e.typeParameters){const r=$Ig$var$lodash_1.map(e.typeParameters,e=>e.name.text),a=$.typeName;let n;n=a.text?a.text:a.right.text;const i=$Ig$var$lodash_1.indexOf(r,n);i>=0&&($=t[i])}return{description:$Ig$var$getNodeDescription(a),format:$Ig$var$getNodeFormat(a),name:n.text,required:!a.questionToken,type:$Ig$var$resolveType($,$.parent),validators:$Ig$var$validatorUtils_1.getPropertyValidators(a)}},$=[],i=0;i<a.length;i++)$.push(n(a[i]));return $}if(e.kind===$Ig$var$ts.SyntaxKind.TypeAliasDeclaration){const t=e,r=[];if(t.type.kind===$Ig$var$ts.SyntaxKind.IntersectionType){for(var o=t.type.types,s=e=>{if(e.kind===$Ig$var$ts.SyntaxKind.TypeReference){const t=$Ig$var$getModelProperties($Ig$var$getModelTypeDeclaration(e.typeName));r.push(...t)}},g=0;g<o.length;g++)s(o[g])}if(t.type.kind===$Ig$var$ts.SyntaxKind.TypeReference){const e=$Ig$var$getModelProperties($Ig$var$getModelTypeDeclaration(t.type.typeName));r.push(...e)}return r}const d=e,l=d.members.filter(e=>{if(e.kind===$Ig$var$ts.SyntaxKind.MethodDeclaration)throw new $Ig$var$exceptions_1.GenerateMetadataError(\"Illegal method declaration on model class\");return!0}).filter(e=>{return!r(e)}).filter(e=>e.kind===$Ig$var$ts.SyntaxKind.PropertyDeclaration).filter(e=>$Ig$var$hasPublicModifier(e)),p=d.members.find(e=>e.kind===$Ig$var$ts.SyntaxKind.Constructor);if(p&&p.parameters){const e=p.parameters.filter(e=>$Ig$var$hasPublicModifier(e));l.push(...e)}for(var y=l,c=r=>{const a=r.name;let n=r.type;if(!n){const e=$Ig$var$metadataGenerator_1.MetadataGenerator.current.typeChecker.getTypeAtLocation(r);n=$Ig$var$metadataGenerator_1.MetadataGenerator.current.typeChecker.typeToTypeNode(e)}if(!n)throw new $Ig$var$exceptions_1.GenerateMetadataError(\"No valid type found for property declaration.\");if(n.kind===$Ig$var$ts.SyntaxKind.TypeReference&&t&&t.length&&e.typeParameters){const r=$Ig$var$lodash_1.map(e.typeParameters,e=>e.name.text),a=n.typeName;let $;$=a.text?a.text:a.right.text;const i=$Ig$var$lodash_1.indexOf(r,$);i>=0&&(n=t[i])}const $=$Ig$var$resolveType(n,r);return{default:$Ig$var$getInitializerValue(r.initializer,$),description:$Ig$var$getNodeDescription(r),format:$Ig$var$getNodeFormat(r),name:a.text,required:!r.questionToken&&!r.initializer,type:$,validators:$Ig$var$validatorUtils_1.getPropertyValidators(r)}},v=[],u=0;u<y.length;u++)v.push(c(y[u]));return v}function $Ig$var$getModelAdditionalProperties(e){if(e.kind===$Ig$var$ts.SyntaxKind.InterfaceDeclaration){const t=e.members.find(e=>e.kind===$Ig$var$ts.SyntaxKind.IndexSignature);if(!t)return;const r=t;if(\"string\"!==$Ig$var$resolveType(r.parameters[0].type).dataType)throw new $Ig$var$exceptions_1.GenerateMetadataError(\"Only string indexers are supported.\");return $Ig$var$resolveType(r.type)}}function $Ig$var$getModelInheritedProperties(e){const t=[];if(e.kind===$Ig$var$ts.SyntaxKind.TypeAliasDeclaration)return[];if(e.kind===$Ig$var$ts.SyntaxKind.TypeLiteral)return[];const r=e.heritageClauses;if(!r)return t;for(var a=r,n=e=>{if(e.types)for(var r=e.types,a=e=>{const r=$Ig$var$getReferenceType(e.expression);if(r.properties)for(var a=r.properties,n=e=>t.push(e),$=0;$<a.length;$++)n(a[$])},n=0;n<r.length;n++)a(r[n])},$=0;$<a.length;$++)n(a[$]);return t}function $Ig$var$hasPublicModifier(e){return!e.modifiers||e.modifiers.every(e=>e.kind!==$Ig$var$ts.SyntaxKind.ProtectedKeyword&&e.kind!==$Ig$var$ts.SyntaxKind.PrivateKeyword)}function $Ig$var$getNodeDescription(e){if(e.kind===$Ig$var$ts.SyntaxKind.TypeLiteral)return;const t=$Ig$var$metadataGenerator_1.MetadataGenerator.current.typeChecker.getSymbolAtLocation(e.name);if(!t)return;e.kind===$Ig$var$ts.SyntaxKind.Parameter&&(t.flags=0);const r=t.getDocumentationComment(void 0);return r.length?$Ig$var$ts.displayPartsToString(r):void 0}function $Ig$var$getNodeFormat(e){return $Ig$var$jsDocUtils_1.getJSDocComment(e,\"format\")}$Ig$exports.getInitializerValue=$Ig$export$getInitializerValue;"},"hash":"b29ab1bfab13fb6ab8e60156f13ad33b","cacheData":{"env":{},"imports":{},"exports":{"resolveType":"$Ig$export$resolveType","getInitializerValue":"$Ig$export$getInitializerValue"},"wildcards":[],"isCommonJS":true}}